--Problem Loading Negative Fixed point values. May have to Dedicate 1 bit in the Immediate itself ugh

x328 CPU and Chipset
//
//Jazza_Hat
//
//Hardware Specifications//
Word size in bits:		32
ISA size in bits:		32
Endianess:				Big
RAM Support:			2^32 Bytes (current implementation is 26 bit or 64MB)
RAM Addressing size:	Bytes
I/O Method:				Memory Mapped
Expansion Memory:		256KB (upto 16KB each)		
Expansion Slots:		16
Interupt Support:		Yes
Interupt Priority:		32 Levels
Unique Interupts:		256
Interupt Table:			256 * 5 Bytes (1.25KB)
//END//
//
//Internal Data type bit widths:
	Byte:		8
	Double:		16
	Word:		32
	Immediate:	Variable
	Pointer:	6
//END//
//Compiler Data type bit widths:		//Not nessasarilly the data itself, but the container of the Data
	Register:	6
	Immediate:	Variable
	Label:		64 Characters
	Address:	21
	Pointer:	6
	PC:			
//END//
//
//Immediates
	Immediates can be signed Integers or signed Fixed point values
	For example, in a 21 bit Immediate, the compiler will turn:
	 69  	into 0 0000 0000 0100 0101 and when this is loaded into a Word in the register 0000 0000 0000 0000 0000 0000 0100 0101
	-69  	into 1 1111 1111 1011 1011 and when this is loaded into a Word in the register 1111 1111 1111 1111 1111 1111 1011 1011
	 69.69f into 0 0100 0101 1011 0001 and when this is loaded into a Word in the register 0000 0000 0000 0000 0100 0101 1011 0001
	-69.69f into 1 ? Add support for negative fixed point values?
//
//Instruction Set Architecture//
	//32 bit
	//0000 0000 .. 0000 0000 .. 0000 0000 .. 0000 0000
//
//NOP //0000 0000 0000 0000 0000 0000 0000 0000 --No Operation
//
//Memory Access
	BYTE [From:	Register/Address/Immediate/Pointer]		[To: Register/Address/Pointer]	//Copy 8 bit Byte
	DBLE [From:	Register/Address/Immediate/Pointer]		[To: Register/Address/Pointer]	//Copy 16 bit Double
	WORD [From:	Register/Address/Immediate/Pointer/PC] 	[To: Register/Address/Pointer]	//Copy 32 bit Word

	PUSH [From:	Register/Immediate/Pointer/PC]											//Push  to Stack
	POP  [To:	Register]																//Pop top value from Stack to Register
	PEEK [To:	Register]																//Peek top value from Stak to Register
	--[[
		The compiler will auto detect what you are trying to make the CPU do.
		Some combinations are not possible due to them being impractical.
		For a list of possible commands and their respective machine code,
		see below.
	]]--
	//
	0TTT TAAA .. AAAB BBBB .. BBBB BBBB .. BBBB BBBB
	T - Type of transfer
	A - Register/Immediate
	B - Address/Immediate/Pointer
		//TTTT-> Permutations
		0000	Register	A 	-> B 	Address  (6  bit, 21 bit) 	BYTE 				//0000 0AAA AAAB BBBB BBBB BBBB --Saves Byte from Register A to Address B
																	BYTE $24 $128		//0000 0011 0000 0000 1000 0000

		0001	Address 	B 	-> A 	Register (21 bit, 6  bit)	BYTE 				//0000 1AAA AAAB BBBB BBBB BBBB --Saves Byte from Address B to Register A
																	BYTE %128 $24		//0000 1011 0000 0000 1000 0000

		0010	Pointer 	A 	-> B 	Register (6  bit, 6  bit)	BYTE 				//0001 0AAA AAA0 0000 00BB BBBB --Saves Byte from Pointer A to Register B
																	BYTE ^6 $24			//0001 0000 1100 0000 0001 1000
		//--------------------------------------------------------------------------------------------------------------------------------
		//
		0011	Register 	A 	-> B 	Address  (6  bit, 21 bit) 	DBLE 				//0001 1AAA AAAB BBBB BBBB BBBB --Saves Double from Register A to Address B
																	DBLE $24 $128		//0001 1011 0000 0000 1000 0000

		0100	Address 	B 	-> A 	Register (21 bit, 6  bit)	DBLE 				//0010 0AAA AAAB BBBB BBBB BBBB --Saves Double from Address B to Register A
																	DBLE %128 $24		//0010 0011 0000 0000 1000 0000

		0101	Pointer 	A 	-> B 	Register (6  bit, 6  bit)	DBLE 				//0010 1AAA AAA0 0000 00BB BBBB --Saves Double from Pointer A to Register B
																	DBLE ^6 $24			//0010 1000 1100 0000 0001 1000
		//--------------------------------------------------------------------------------------------------------------------------------
		//
		0110	Register 	A 	-> B 	Address  (6  bit, 21 bit) 	WORD 				//0011 0AAA AAAB BBBB BBBB BBBB --Saves Word from Register A to Address B
																	WORD $24 $128		//0011 0011 0000 0000 1000 0000

		0111	Address 	B 	-> A 	Register (21 bit, 6  bit)	WORD 				//0011 1AAA AAAB BBBB BBBB BBBB --Saves Word from Address B to Register A
																	WORD %128 $24		//0011 1011 0000 0000 1000 0000

		1000	Pointer 	A 	-> B 	Register (6  bit, 6  bit)	WORD 				//0100 0AAA AAA0 0000 00BB BBBB --Saves Word from Pointer A to Register B
																	WORD ^6 $24			//0100 0000 1100 0000 0001 1000

		1001	Immediate 	B 	-> A 	Register (21 bit, 6  bit)	WORD 				//0100 1AAA AAAB BBBB BBBB BBBB --Saves 21 bits B to Register A
																	WORD 69 $24			//0100 1011 0000 0000 0100 0101
		//--------------------------------------------------------------------------------------------------------------------------------
		//
		1010	Register 	A 	-> 		Stack 	 (6  Bit)			PUSH  				//0101 0AAA AAA0 0000 0000 0000 --Pushes Register A to Stack
																	PUSH $24			//0101 0011 0000 0000 0000 0000

		1011	Immediate 	A+B -> 		Stack    (27 bit)			PUSH				//0101 1AAA AAAB BBBB BBBB BBBB --Pushes 21 bit Immediate [AAA AAAB BBBB BBBB BBBB] to Stack
																	PUSH 69

		1100	Pointer 	A 	-> 		Stack    (6  bit)			PUSH 				//0110 0AAA AAA0 0000 0000 0000 --Pushes Pointer A to Stack
																	PUSH

		1101	PC 			PC	-> 		Stack 						PUSH 				//0110 1000 0000 0000 0000 0000 --Pushes PC to Stack
																	PUSH

		1110	Stack 	 		-> A	Register (6  bit)			POP 				//0111 0AAA AAA0 0000 0000 0000 --Pushes top value in Stack to Register A
																	POP

		1111	Stack 			-> A	Register (6  bit)			PEEK 	 			//0111 1AAA AAA0 0000 0000 0000 --Peeks top value in Stack to Register A
																	PEEK
		//
	//
//
//
//Other Operations
	1OOO 0000 .. 0000 0000 .. 0000 0000 .. 0000 0000
	OOO - Operations
		//OOO-> Permutations
		000		NOP
		001		EXE
						1001 OOOO .. OIAA AAAA .. AAAJ BBBB .. BBCC CCCC
						O - Operation
						I - Use A as Immediate
						A - A Data
						J - Use B as Immediate
						B - B Data
						C - C Data
						(Some operations may use A, J and B as Immediate)
		//
		010		CONV
						1010 OOOI .. AAAA AAAA .. AAAA AAAA .. AACC CCCC
						O - Operation
						I - Use A as Immediate
						A - A Data
						C - C Data
		011		JMP
						1011 OOOO .. 0000 0000 .. 0000 0000 .. 0000 0000
						O - Operation
							0 	-	1011 OOOO .. IIII IIII .. IIII IIII .. IIII IIII
										I - Immediate
							1,2 -	1011 OOOO .. AAAA AA00 .. 0000 0000 .. 0000 0000
										A - A Data
							3-8 -	1011 OOOO .. AAAA AABB .. BBBB IIII .. IIII IIII
										A - A Data
										B - B Data
										I - Immediate
		100		JMPF
						1100 OOOO .. IIII IIII .. IIII IIII .. IIII IIII
							I - Immediate
						1100 1011 .. FFFF FF00 .. 0000 0000 .. 0000 0000 - CFLG
							F - Flag to clear
		101		MEM
						1101 00RM .. MMMM MMMM .. MMMM MMMM .. MMMM MMMM - MEMB
							R - Register or Immediate
							M - Memory Offset
						1101 01AA .. AAAA IBBB .. BBB0 0000 .. 0000 0000 - MEML
						1101 10AA .. AAAA IBBB .. BBB0 0000 .. 0000 0000 - MEMU
							A - A Data
							I - Use B as Immediate
							B - B Data
		110		IRQ
						1110 01 AA .. AAAA IBBB .. BBB0 0000 .. 0000 0000
		111		LOOP
						1111 AAAA .. AACC CIBB .. BBBB XXXX .. XXXX ZZZZ
							A - A Data
							C - Condition
							I - Use B as Immediate
							X - Jump Offset
							Z - Modify A Offset
		//
	//
//
//
//Instructions
//

//EXE Operations 0-31
	OR   [A: Register/Immediate]	[B:	Register/Immediate] [C:	Register]			//Logical OR
	NOR  [A: Register/Immediate]	[B:	Register/Immediate] [C:	Register]			//Logical NOR
	AND  [A: Register/Immediate]	[B:	Register/Immediate] [C:	Register]			//Logical AND
	NAND [A: Register/Immediate]	[B:	Register/Immediate] [C:	Register]			//Logical NAND
	XOR  [A: Register/Immediate]	[B:	Register/Immediate] [C:	Register]			//Logical XOR
	XNOR [A: Register/Immediate]	[B:	Register/Immediate] [C:	Register]			//Logical XNOR

	ADD  [A: Register/Immediate]	[B:	Register/Immediate] [C:	Register]			//Adition
	SUB  [A: Register/Immediate]	[B:	Register/Immediate] [C:	Register]			//Subtraction
	MUL  [A: Register/Immediate]	[B:	Register/Immediate] [C:	Register]			//Multiplication
	DIV  [A: Register/Immediate]	[B:	Register/Immediate] [C:	Register]			//Division
	MOD  [A: Register/Immediate]	[B:	Register/Immediate] [C:	Register]			//Modulus
	NEG  [A: Register/Immediate]							[C:	Register]			//Negative (2s Compliment)
	ABS  [A: Register/Immediate]							[C:	Register]			//Absolute 

	FADD [A: Register/Immediate]	[B:	Register/Immediate] [C:	Register]			//Fixed Point Adition
	FSUB [A: Register/Immediate]	[B:	Register/Immediate] [C:	Register]			//Fixed Point Subtraction
	FMUL [A: Register/Immediate]	[B:	Register/Immediate] [C:	Register]			//Fixed Point Multiplication
	FDIV [A: Register/Immediate]	[B:	Register/Immediate] [C:	Register]			//Fixed Point Division
	FSQT [A: Register/Immediate]							[C:	Register]			//Fixed Point Square Root
	FNEG [A: Register/Immediate]							[C:	Register]			//Fixed Point Negative
	FABS [A: Register/Immediate]							[C:	Register]			//Fixed Point Absolute

	LLSH [A: Register/Immediate]	[B:	Register/Immediate] [C:	Register]			//Logical Left Shift
	LRSH [A: Register/Immediate]	[B:	Register/Immediate] [C:	Register]			//Logical Right Shift
	ARSH [A: Register/Immediate]	[B:	Register/Immediate] [C:	Register]			//Arithmatic Right Shift
	RLSH [A: Register/Immediate]	[B:	Register/Immediate] [C:	Register]			//Rotate Left Shift
	RRSH [A: Register/Immediate]	[B:	Register/Immediate] [C:	Register]			//Rotate Right Shift

	ENDN [A: Register]										[C:	Register]			//Swap Endianess (System still computes in Big Endian, but allows sending of data to Little Endian Systems)
	NBIT [A: Register]										[C:	Register]			//Number of 1 bits
	HIG0 [A: Register]										[C:	Register]			//Position of Highest 0 bit
	HIG1 [A: Register]										[C:	Register]			//Position of Highest 1 bit
	LOW0 [A: Register]										[C:	Register]			//Position of Lowest 0 bit
	LOW1 [A: Register/Immediate]							[C:	Register]			//Position of Lowest 1 bit

	RAND 													[C: Register]			//Random 32 bit Word
//
//CONV Operations 0-7
	INTF [A: Register/Immediate]							[C:	Register]			//Integer to Fixed Point
	FINT [A: Register/Immediate]							[C:	Register]			//Fixed Point to Integer
	INAS [A: Register/Immediate]							[C:	Register]			//Integer to ASCII
	ASIN [A: Register/Immediate]							[C:	Register]			//ASCII to Integer
	INAL [A: Register/Immediate]							[C:	Register]			//Integer to ASCII Alphabet (Integer 1 = ASCII A...)
	ALIN [A: Register/Immediate]							[C:	Register]			//ASCII Alphabet to Integer (^)

	SIN  [A: Register/Immediate]							[C:	Register]			//Sine value (Degrees) (Uses Fixed point)
	COS  [A: Register/Immediate]							[C:	Register]			//Cosine Value (Degrees) (Uses Fixed point)
//
//JMP Operations 0-8
	JMP  [Relative Jump: Register/Immediate]										//Relative Jump with Immediate
	JMPA [Absolute Jump: Register/Immediate]										//Absolute Jump with Register

	JE   [A: Register]	[B:	Register/Immediate] [Jump: Immediate]					//Relative Jump when A == B
	JNE  [A: Register]	[B:	Register/Immediate] [Jump: Immediate]					//Relative Jump when A != B
	JG   [A: Register]	[B:	Register/Immediate] [Jump: Immediate]					//Relative Jump when A > B
	JGE  [A: Register]	[B:	Register/Immediate] [Jump: Immediate]					//Relative Jump when A >= B
	JL   [A: Register]	[B:	Register/Immediate] [Jump: Immediate]					//Relative Jump when A < B
	JLE  [A: Register]	[B:	Register/Immediate] [Jump: Immediate]					//Relative Jump when A <= B
//
//JMPF
	JAO  [Jump: Immediate]															//Relative Jump when Arithmatic Overflow
	JANO [Jump: Immediate]															//Relative Jump when not Arithmatic Overflow
	JAU  [Jump: Immediate]															//Relative Jump when Arithmatic Underflow
	JANU [Jump: Immediate]															//Relative Jump when not Arithmatic Underflow
	JSO  [Jump: Immediate]															//Relative Jump when Stack Overflow
	JSNO [Jump: Immediate]															//Relative Jump when not stack Overflow
	JSU  [Jump: Immediate]															//Relative Jump when Stack Underflow
	JSNU [Jump: Immediate]															//Relative Jump when not Stack Underflow
	JNEG [Jump: Immediate]															//Relative Jump when a FSQT happens on a negative number
	JDIV [Jump: Immediate]															//Relative Jump when a Division by 0 happens
	JRND [Jump: Immediate]															//Relative Jump Randomly (50/50)

	CFLG [Flags to clear: AO AU SO SU NEG DIV]										//Clear Flags manually (Flags are reset anyway when you successfully Jump)
//
//MEM
	MEMB [Address Offset: Register/Immediate]										//Base offset for memory access
	MCPL [Lower Address to copy to: Register] [Port: Register/Immediate]			//Memory Copy Lower Address
	MCPU [Lower Address to copy to: Register] [Port: Register/Immediate]			//Memory Copy Upper Address -Operation doent start til Upper address is given -Values get reset on success
//
//IRQ
	IRH  [Interupt: Register/Immediate] [Address/Data: 	Register/Immediate]			//Interupt Handler: set Interupt Address
	IRE  [Interupt: Register/Immediate] [Expansion: 	Register/Immediate]			//Which Expansion The Interupt is sent to
	IPL  [Interupt: Register/Immediate] [Priority: 		Register/Immediate]			//Interupt Priority Level: sets Interupt to the Priority Level
	IRQS [Interupt: Register/Immediate] 											//Software Interupt
	IRQM [Priority: Register/Immediate] 											//Masks Interupts less than this Priority
	
//IPL 8, 8, 5 (bits)
//
//LOOP
	LOOP [A: Register] [Condition] [B: Register/Immediate] [Relative Jump: Immediate] [Modify A: Immediate]
	//Loops back with a Relative Jump when condition met, modifies A when constant is given
//END//


//Boot process
	Start Processor
	Initiate Devices
	Attempt to read instruction 000000 from RAM
	Northbridge will intercept with BIOS code
	Execute BIOS
	Find boot order inside -BootTable
	Copy Initial Program over (May be boot loader)

//End


//IRQ
	IRQ from device
	Wait for instruction to finish
	Northbridge Pause PC
		Insert Instruction to send PC to stack
	Lookup Interupt table
	Fetch Address
	//Execute interupt
	Pop all data data used from stack
	Pop PC and JMPI to new PC
//End

//Devices have x Bytes split between them
//At startup they ask to get as much RAM as they can
//If they do not get enough then an interupt is made
//Devices will still work until they try to access invalid memory and then another interupt is made